// ZmqServerDealer.hpp
#pragma once
#include <zmq.hpp>

#include <atomic>
#include <chrono>
#include <condition_variable>
#include <cstdint>
#include <deque>
#include <functional>
#include <mutex>
#include <string>
#include <thread>

class ZmqServerDealer {
public:
    using RxHandler = std::function<void(const std::string&)>;

    ZmqServerDealer(std::string endpoint, std::string routingId = "")
        : endpoint_(std::move(endpoint)), routingId_(std::move(routingId)),
          ctx_(1), running_(false) {}

    ~ZmqServerDealer() { stop(); }

    // onMessage sẽ chạy trong "rx thread riêng" (không phải IO thread)
    void start(RxHandler onMessage) {
        if (running_.exchange(true)) return;
        onMessage_ = std::move(onMessage);

        // Thread 1: IO thread owns dealer socket (ONLY thread touching dealer)
        ioThread_ = std::thread([this] { ioLoop(); });

        // Thread 2: RX worker thread (runs callback / business logic)
        rxThread_ = std::thread([this] { rxLoop(); });
    }

    void stop() {
        if (!running_.exchange(false)) return;

        // wake threads
        {
            std::lock_guard<std::mutex> lk(txMtx_);
            // nothing
        }
        txCv_.notify_all();

        {
            std::lock_guard<std::mutex> lk(rxMtx_);
            // nothing
        }
        rxCv_.notify_all();

        if (ioThread_.joinable()) ioThread_.join();
        if (rxThread_.joinable()) rxThread_.join();
    }

    // Thread-safe API: can be called from ANY thread.
    void send(const std::string& msg) {
        if (!running_.load()) return;
        {
            std::lock_guard<std::mutex> lk(txMtx_);
            txQueue_.push_back(msg);
        }
        txCv_.notify_one();
    }

private:
    // ======================
    // RX worker thread stuff
    // ======================
    void rxLoop() {
        while (running_.load()) {
            std::string msg;
            {
                std::unique_lock<std::mutex> lk(rxMtx_);
                rxCv_.wait_for(lk, std::chrono::milliseconds(200), [&] {
                    return !running_.load() || !rxQueue_.empty();
                });
                if (!running_.load() && rxQueue_.empty()) break;
                if (rxQueue_.empty()) continue;
                msg = std::move(rxQueue_.front());
                rxQueue_.pop_front();
            }
            // callback outside lock
            if (onMessage_) onMessage_(msg);
        }
    }

    // ======================
    // IO thread (ONLY owner of dealer socket)
    // ======================
    void ioLoop() {
        zmq::socket_t dealer(ctx_, zmq::socket_type::dealer);

        // Optional routing id (helps peer identify you)
        if (!routingId_.empty()) {
            dealer.set(zmq::sockopt::routing_id, routingId_);
        }

        // Practical timeouts to allow graceful stop
        dealer.set(zmq::sockopt::rcvtimeo, 50);
        dealer.set(zmq::sockopt::sndtimeo, 50);
        dealer.set(zmq::sockopt::linger, 0);

        dealer.connect(endpoint_);

        while (running_.load()) {
            // 1) Receive from peer (non-blocking with rcvtimeo)
            zmq::message_t in;
            if (dealer.recv(in, zmq::recv_flags::none)) {
                std::string s(static_cast<char*>(in.data()), in.size());
                {
                    std::lock_guard<std::mutex> lk(rxMtx_);
                    rxQueue_.push_back(std::move(s));
                }
                rxCv_.notify_one();
            }

            // 2) Send pending tx messages (drain queue)
            // Wait a bit only if nothing to send to reduce CPU
            std::string out;
            {
                std::unique_lock<std::mutex> lk(txMtx_);
                if (txQueue_.empty()) {
                    txCv_.wait_for(lk, std::chrono::milliseconds(10), [&] {
                        return !running_.load() || !txQueue_.empty();
                    });
                }
                if (!running_.load() && txQueue_.empty()) break;
                if (!txQueue_.empty()) {
                    out = std::move(txQueue_.front());
                    txQueue_.pop_front();
                }
            }

            if (!out.empty()) {
                // If you need multipart frames, do it here in IO thread.
                dealer.send(zmq::buffer(out), zmq::send_flags::none);
            }
        }
    }

private:
    std::string endpoint_;
    std::string routingId_;

    zmq::context_t ctx_;
    std::atomic<bool> running_;

    RxHandler onMessage_;
    std::thread ioThread_;
    std::thread rxThread_;

    // outgoing queue
    std::mutex txMtx_;
    std::condition_variable txCv_;
    std::deque<std::string> txQueue_;

    // incoming queue (IO -> RX worker)
    std::mutex rxMtx_;
    std::condition_variable rxCv_;
    std::deque<std::string> rxQueue_;
};
