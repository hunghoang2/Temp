// ZmqServer.hpp / .cpp (gộp 1 file cho dễ copy)
// Requires: ZeroMQ + cppzmq (zmq.hpp)
// Compile (example): g++ -std=c++17 main.cpp -lzmq -pthread

#include <zmq.hpp>

#include <atomic>
#include <chrono>
#include <condition_variable>
#include <cstdint>
#include <deque>
#include <mutex>
#include <optional>
#include <string>
#include <thread>
#include <vector>
#include <functional>
#include <iostream>

class ZmqServer {
public:
    using ReceiveCallback =
        std::function<void(const std::string& clientId, const std::string& payload)>;

    struct Outgoing {
        std::string clientId;  // ROUTER identity
        std::string payload;
    };

    explicit ZmqServer(std::string bindEndpoint,
                       ReceiveCallback cb = nullptr)
        : endpoint_(std::move(bindEndpoint)),
          onReceive_(std::move(cb)),
          ctx_(1),
          running_(false) {}

    ~ZmqServer() { stop(); }

    ZmqServer(const ZmqServer&) = delete;
    ZmqServer& operator=(const ZmqServer&) = delete;

    void start() {
        bool expected = false;
        if (!running_.compare_exchange_strong(expected, true)) {
            return; // already running
        }
        ioThread_ = std::thread(&ZmqServer::ioLoop_, this);
    }

    void stop() {
        bool expected = true;
        if (!running_.compare_exchange_strong(expected, false)) {
            return; // already stopped
        }

        // Wake IO thread
        {
            std::lock_guard<std::mutex> lk(outMtx_);
            // no-op
        }
        outCv_.notify_all();

        if (ioThread_.joinable()) ioThread_.join();
    }

    // Thread-safe: can be called from any thread.
    // Returns false if server not running.
    bool sendMessage(const std::string& clientId, const std::string& payload) {
        if (!running_.load()) return false;
        {
            std::lock_guard<std::mutex> lk(outMtx_);
            outQueue_.push_back(Outgoing{clientId, payload});
        }
        outCv_.notify_one();
        return true;
    }

    // Optional: set callback after creation
    void setReceiveCallback(ReceiveCallback cb) {
        std::lock_guard<std::mutex> lk(cbMtx_);
        onReceive_ = std::move(cb);
    }

private:
    void ioLoop_() {
        // Socket belongs ONLY to this thread
        zmq::socket_t router(ctx_, zmq::socket_type::router);

        // Some recommended options for ROUTER
        // router.set(zmq::sockopt::router_mandatory, 1); // fail if unknown identity
        router.set(zmq::sockopt::linger, 0);

        try {
            router.bind(endpoint_);
        } catch (const zmq::error_t& e) {
            std::cerr << "ZmqServer bind failed: " << e.what() << "\n";
            running_.store(false);
            return;
        }

        // Poll interval: balance latency & CPU
        constexpr auto kPollStep = std::chrono::milliseconds(10);

        while (running_.load()) {
            // 1) Receive incoming (non-blocking poll)
            zmq::pollitem_t items[] = {
                { static_cast<void*>(router), 0, ZMQ_POLLIN, 0 }
            };

            try {
                zmq::poll(items, 1, kPollStep);
            } catch (const zmq::error_t& e) {
                if (!running_.load()) break;
                std::cerr << "ZmqServer poll error: " << e.what() << "\n";
                continue;
            }

            if (items[0].revents & ZMQ_POLLIN) {
                // ROUTER message frames commonly: [identity][empty delimiter][payload]
                // But can vary if client uses DEALER etc.
                std::vector<zmq::message_t> frames;
                while (true) {
                    zmq::message_t part;
                    auto res = router.recv(part, zmq::recv_flags::none);
                    if (!res) break;
                    frames.push_back(std::move(part));
                    bool more = router.get(zmq::sockopt::rcvmore);
                    if (!more) break;
                }

                if (!frames.empty()) {
                    std::string clientId = frames[0].to_string();

                    // Heuristic: payload at last frame
                    std::string payload = frames.back().to_string();

                    ReceiveCallback cbCopy;
                    {
                        std::lock_guard<std::mutex> lk(cbMtx_);
                        cbCopy = onReceive_;
                    }
                    if (cbCopy) cbCopy(clientId, payload);
                }
            }

            // 2) Flush outgoing queue
            flushOutgoing_(router);

            // 3) Also wait a tiny bit if queue is empty (avoid busy loop)
            //    But don't block too long; we already poll()ed for recv.
            if (isOutgoingEmpty_()) {
                std::unique_lock<std::mutex> lk(outMtx_);
                outCv_.wait_for(lk, std::chrono::milliseconds(1));
            }
        }

        // Best effort flush before exit
        flushOutgoing_(router);
        try {
            router.close();
        } catch (...) {}
    }

    bool isOutgoingEmpty_() const {
        std::lock_guard<std::mutex> lk(outMtx_);
        return outQueue_.empty();
    }

    void flushOutgoing_(zmq::socket_t& router) {
        // pop batch to reduce lock time
        std::deque<Outgoing> batch;
        {
            std::lock_guard<std::mutex> lk(outMtx_);
            batch.swap(outQueue_);
        }

        for (const auto& msg : batch) {
            try {
                // ROUTER send: [identity][empty delimiter][payload]
                router.send(zmq::buffer(msg.clientId), zmq::send_flags::sndmore);
                router.send(zmq::message_t{},          zmq::send_flags::sndmore);
                router.send(zmq::buffer(msg.payload),  zmq::send_flags::none);
            } catch (const zmq::error_t& e) {
                // If client disappeared, send may fail depending on options
                std::cerr << "ZmqServer send error: " << e.what() << "\n";
            }
        }
    }

private:
    std::string endpoint_;

    // callback
    mutable std::mutex cbMtx_;
    ReceiveCallback onReceive_;

    // ZMQ context must outlive sockets
    zmq::context_t ctx_;

    // IO thread
    std::thread ioThread_;
    std::atomic<bool> running_;

    // Thread-safe outgoing queue
    mutable std::mutex outMtx_;
    std::condition_variable outCv_;
    std::deque<Outgoing> outQueue_;
};
