void CameraWorker::start() {
    if (running_) return;
    running_ = true;

    if (!cap_.open(camIndex_, cv::CAP_ANY)) {
        emit status("Không mở được camera.");
        running_ = false;
        return;
    }

    // Giảm độ trễ đọc
    cap_.set(cv::CAP_PROP_BUFFERSIZE, 1);
    // (Tùy cam) cố gắng yêu cầu 25 FPS – không phải thiết bị nào cũng hỗ trợ
    cap_.set(cv::CAP_PROP_FPS, 25);

    const int target_fps = 25;
    const std::chrono::milliseconds period(1000 / target_fps); // 40ms
    auto next_deadline = std::chrono::steady_clock::now() + period;

    bool skipUpdate = false; // nếu quá ngân sách thời gian, bỏ update CSRT khung sau

    while (running_) {
        auto loop_start = std::chrono::steady_clock::now();

        // ===== Lấy frame mới nhất: drop khung cũ nếu driver đang đẩy nhanh =====
        cv::Mat frame;
        // Ít nhất 1 lần read; nếu driver cho phép, dùng grab() để hút đến frame mới nhất
        // (grab() rẻ hơn retrieve(); retrieve chỉ 1 lần để giải mã)
        // Một vòng hút ngắn (tối đa ~2ms) để không phá nhịp 40ms.
        int grabbed = 0;
        auto grab_deadline = loop_start + std::chrono::milliseconds(2);
        do {
            if (!cap_.grab()) break;
            grabbed++;
        } while (std::chrono::steady_clock::now() < grab_deadline);
        if (grabbed == 0) {
            // Nếu không grab được, thử read truyền thống
            if (!cap_.read(frame) || frame.empty()) {
                emit status("Mất khung hình từ camera.");
                // vẫn tiến tới deadline tiếp theo
            }
        } else {
            if (!cap_.retrieve(frame) || frame.empty()) {
                emit status("Không retrieve được khung hình.");
            }
        }

        if (!frame.empty()) {
            ensureScaleFactors(frame.cols, frame.rows);

            // ===== Tracking (giữ ngân sách 40ms/khung) =====
            if (tracking_) {
                if (tracker_) {
                    bool doUpdate = !skipUpdate; // nếu khung trước quá giờ, khung này không update để bắt kịp
                    if (doUpdate) {
                        bool ok = tracker_->update(frame, bbox_);
                        if (ok) {
                            cv::rectangle(frame, bbox_, cv::Scalar(0, 255, 0), 2);
                        } else {
                            cv::putText(frame, "Tracking lost", {20, 40}, cv::FONT_HERSHEY_SIMPLEX, 1.0, {0,0,255}, 2);
                        }
                    } else {
                        // Không update, chỉ vẽ bbox cũ
                        cv::rectangle(frame, bbox_, cv::Scalar(0, 200, 200), 1);
                    }
                } else {
                    emit requestROI();
                }
            }

            emit frameReady(matToQImage(frame));
        }

        // ===== Pacing: giữ đúng 25 fps =====
        auto now = std::chrono::steady_clock::now();
        // Nếu xử lý nhanh hơn budget, ngủ đến deadline
        if (now < next_deadline) {
            auto sleep_dur = next_deadline - now;
            // Dùng QThread::msleep cho độ chính xác ms (OS còn tuỳ)
            auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(sleep_dur).count();
            if (ms > 0) QThread::msleep(static_cast<unsigned long>(ms));
            skipUpdate = false; // có thời gian “nghỉ” => khung sau update bình thường
        } else {
            // Quá deadline: bỏ ngủ, và khung sau tắt update CSRT để đuổi kịp
            skipUpdate = true;
        }

        // Đặt deadline cho khung kế
        // Dùng bước rời rạc theo period để tránh trôi nhịp
        do {
            next_deadline += period;
        } while (std::chrono::steady_clock::now() > next_deadline + period); 
        // (tuỳ chọn) nếu bị “trôi” quá xa, kéo về hiện tại + period
        if (std::chrono::steady_clock::now() - next_deadline > period*5) {
            next_deadline = std::chrono::steady_clock::now() + period;
        }
    }

    if (cap_.isOpened()) cap_.release();
    tracker_.reset();
    tracking_ = false;
}
