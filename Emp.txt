#pragma once

#include <QObject>
#include <QThread>
#include <QMutex>
#include <QWaitCondition>
#include <QQueue>
#include <QByteArray>
#include <QString>
#include <atomic>
#include <zmq.hpp>

class ZmqClient : public QThread {
    Q_OBJECT
public:
    explicit ZmqClient(QObject *parent = nullptr)
        : QThread(parent),
          m_ctx(1),
          m_socket(nullptr),
          m_running(false),
          m_connected(false),
          m_sndHwm(10000),
          m_lingerMs(0)
    {}

    ~ZmqClient() override {
        stop();
        wait();
        closeSocket();
    }

    // --- Config ---
    void setEndpoint(const QString &ep) {
        QMutexLocker lock(&m_cfgMtx);
        m_endpoint = ep;
    }
    void setHighWaterMark(int hwm) { m_sndHwm = hwm; }
    void setLingerMs(int ms) { m_lingerMs = ms; }

public slots:
    void startClient() {
        if (isRunning()) return;
        m_running = true;
        QThread::start();
    }
    void stop() {
        m_running = false;
        m_queueNotEmpty.wakeAll();
    }

    // ✅ Thread-safe — gọi từ thread khác thoải mái
    void sendMessage(const QByteArray &payload) {
        {
            QMutexLocker lock(&m_qMtx);
            m_queue.enqueue(payload);
        }
        m_queueNotEmpty.wakeOne();
    }

signals:
    void connected();
    void disconnected();
    void error(QString msg);
    void stats(uint64_t sentCount);

protected:
    void run() override {
        uint64_t sent = 0;

        while (m_running) {
            ensureSocket();
            if (!m_connected) {
                msleep(500);
                continue;
            }

            while (m_running && m_connected) {
                QByteArray payload;
                {
                    QMutexLocker lock(&m_qMtx);
                    if (m_queue.isEmpty()) {
                        m_queueNotEmpty.wait(&m_qMtx, 200);
                        if (m_queue.isEmpty()) continue;
                    }
                    payload = m_queue.dequeue();
                }

                try {
                    zmq::message_t msg(payload.size());
                    std::memcpy(msg.data(), payload.constData(), payload.size());
                    auto ok = m_socket->send(msg, zmq::send_flags::dontwait);
                    if (ok) {
                        ++sent;
                        if (sent % 1000 == 0)
                            emit stats(sent);
                    }
                } catch (const zmq::error_t &e) {
                    emit error(QString("ZMQ send error: %1").arg(e.what()));
                    handleBroken();
                    break;
                }
            }
        }
    }

private:
    void ensureSocket() {
        if (m_connected && m_socket) return;
        closeSocket();

        QString ep;
        {
            QMutexLocker lock(&m_cfgMtx);
            ep = m_endpoint;
        }
        if (ep.isEmpty()) {
            emit error("ZMQ endpoint is empty");
            msleep(500);
            return;
        }

        try {
            m_socket = new zmq::socket_t(m_ctx, zmq::socket_type::push);
            m_socket->set(zmq::sockopt::sndhwm, m_sndHwm);
            m_socket->set(zmq::sockopt::linger, m_lingerMs);
            m_socket->connect(ep.toStdString());

            m_connected = true;
            emit connected();
        } catch (const zmq::error_t &e) {
            emit error(QString("ZMQ connect failed: %1").arg(e.what()));
            handleBroken();
        }
    }

    void handleBroken() {
        closeSocket();
        emit disconnected();
    }

    void closeSocket() {
        if (m_socket) {
            try { m_socket->close(); } catch (...) {}
            delete m_socket;
            m_socket = nullptr;
        }
        m_connected = false;
    }

private:
    zmq::context_t m_ctx;
    zmq::socket_t *m_socket;

    std::atomic<bool> m_running;
    std::atomic<bool> m_connected;

    QMutex m_cfgMtx;
    QString m_endpoint;
    int m_sndHwm;
    int m_lingerMs;

    QMutex m_qMtx;
    QWaitCondition m_queueNotEmpty;
    QQueue<QByteArray> m_queue;
};
