double coarse_sine_deg(double t, double center_deg, double A_deg, double f_hz) {
    return center_deg + A_deg * std::sin(2.0 * M_PI * f_hz * t);
}


void update_pan_adaptive(
    const PanParams* P,
    PanState* S,
    float dt,
    float u,
    float conf,
    float cx)
{
  // --------- SAFETY: dt ----------
  dt = clampf(dt, 1e-3f, 0.2f);

  // --------- 1) Image error (deg) ----------
  float e = (u - cx) * P->deg_per_px_x;

  // Deadband
  if (e > -P->e_db_deg && e < P->e_db_deg)
    e = 0.0f;

  // --------- INIT / WARM-UP HANDLING ----------
  if (!S->valid) {
    // Frame đầu tiên sau reset:
    // - không tính vận tốc
    // - không feed-forward
    // - không accel limit
    float w_cmd = P->kp_min * e;

    // Clamp tốc độ
    w_cmd = clampf(w_cmd, -P->w_max, +P->w_max);

    // Integrate trực tiếp
    S->az_sp = wrap360(S->az_sp + w_cmd * dt);

    // Khởi tạo state cho frame sau
    S->u_prev     = u;
    S->w_tgt_prev = 0.0f;
    S->w_tgt_f    = 0.0f;
    S->w_cmd_prev = w_cmd;

    S->warmup_cnt++;

    // Sau 1–2 frame thì coi như valid
    if (S->warmup_cnt >= 2) {
      S->valid = 1;
    }

    send_pan_absolute(S->az_sp);
    return;
  }

  // --------- 2) Target angular rate (deg/s) ----------
  float w_tgt = ((u - S->u_prev) / dt) * P->deg_per_px_x;
  S->u_prev = u;

  // --------- 3) Speed scale ----------
  float sw = clampf((fabsf(w_tgt) - P->w_low) /
                    (P->w_high - P->w_low), 0.0f, 1.0f);

  // --------- 4) Adaptive filter ----------
  float alpha = P->alpha_slow -
                (P->alpha_slow - P->alpha_fast) * sw;
  S->w_tgt_f = alpha * S->w_tgt_f + (1.0f - alpha) * w_tgt;

  // --------- 5) Angular acceleration ----------
  float a_img = (w_tgt - S->w_tgt_prev) / dt;
  S->w_tgt_prev = w_tgt;

  float gate = 1.0f -
    clampf((fabsf(a_img) - P->a_soft) /
           (P->a_hard - P->a_soft), 0.0f, 1.0f);

  gate *= clampf(conf, 0.0f, 1.0f);

  // --------- 6) Adaptive Kp ----------
  float se = clampf((fabsf(e) - P->e_small) /
                    (P->e_large - P->e_small), 0.0f, 1.0f);
  float Kp = P->kp_min +
             (P->kp_max - P->kp_min) * se;

  // --------- 7) Adaptive Kff ----------
  float Kff = P->kff_min +
              (P->kff_max - P->kff_min) * sw;

  // --------- 8) Commanded setpoint rate ----------
  float w_cmd = Kp * e + (Kff * gate) * S->w_tgt_f;

  // --------- 9) Clamp speed ----------
  w_cmd = clampf(w_cmd, -P->w_max, +P->w_max);

  // --------- 10) Clamp accel ----------
  float dw = P->a_max * dt;
  w_cmd = clampf(w_cmd,
                 S->w_cmd_prev - dw,
                 S->w_cmd_prev + dw);
  S->w_cmd_prev = w_cmd;

  // --------- 11) Integrate ----------
  S->az_sp = wrap360(S->az_sp + w_cmd * dt);

  send_pan_absolute(S->az_sp);
}
