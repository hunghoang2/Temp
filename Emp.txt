#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <string>
#include <thread>
#include <chrono>
#include <csignal>
#include <cstdint>
#include <vector>

// Cho RS485 / serial
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

// =====================
// Helper: gọi piTest cho analog (SV6051, PT1000, SV7151)
// =====================
static bool runCommandAndReadLine(const std::string &cmd, std::string &outLine)
{
    FILE *pipe = popen(cmd.c_str(), "r");
    if (!pipe)
        return false;

    char buffer[256];
    if (!fgets(buffer, sizeof(buffer), pipe)) {
        pclose(pipe);
        return false;
    }
    pclose(pipe);

    outLine = buffer;
    return true;
}

// =====================
// RevPi analog input qua piTest
// =====================
class RevPiAnalogInput
{
public:
    explicit RevPiAnalogInput(std::string varName,
                              double rawMax = 32767.0)
        : m_varName(std::move(varName)),
          m_rawMax(rawMax)
    {}

    bool readRaw(long &raw) const
    {
        std::string cmd = "piTest -q -r " + m_varName;
        std::string line;
        if (!runCommandAndReadLine(cmd, line)) {
            return false;
        }

        char *endptr = nullptr;
        long value = std::strtol(line.c_str(), &endptr, 10);
        if (endptr == line.c_str()) {
            return false;
        }

        if (value < 0) value = 0;
        if (value > static_cast<long>(m_rawMax)) value = static_cast<long>(m_rawMax);

        raw = value;
        return true;
    }

    double rawMax() const { return m_rawMax; }
    const std::string &name() const { return m_varName; }

private:
    std::string m_varName;
    double      m_rawMax;
};

// =====================
// Base class cảm biến analog
// =====================
class SensorBase
{
public:
    explicit SensorBase(RevPiAnalogInput channel)
        : m_channel(std::move(channel))
    {}

    virtual ~SensorBase() = default;

    virtual bool readValue(double &value) = 0;

protected:
    RevPiAnalogInput m_channel;
};

// =====================
// SV6051: Flow 4–20 mA
// =====================
class SV6051FlowSensor : public SensorBase
{
public:
    SV6051FlowSensor(const std::string &varName,
                     double rawMax   = 32767.0,
                     double maMin    = 4.0,
                     double maMax    = 20.0,
                     double flowMin  = 0.0,
                     double flowMax  = 500.0)
        : SensorBase(RevPiAnalogInput(varName, rawMax)),
          m_maMin(maMin),
          m_maMax(maMax),
          m_flowMin(flowMin),
          m_flowMax(flowMax)
    {}

    bool readValue(double &flow) override
    {
        long raw = 0;
        if (!m_channel.readRaw(raw)) {
            return false;
        }

        double mA = m_maMin + (double(raw) / m_channel.rawMax()) * (m_maMax - m_maMin);

        if (mA <= m_maMin)
            flow = m_flowMin;
        else if (mA >= m_maMax)
            flow = m_flowMax;
        else {
            double ratio = (mA - m_maMin) / (m_maMax - m_maMin);
            flow = m_flowMin + ratio * (m_flowMax - m_flowMin);
        }

        return true;
    }

private:
    double m_maMin;
    double m_maMax;
    double m_flowMin;
    double m_flowMax;
};

// =====================
// SV7151: Pressure 4–20 mA (ví dụ 0–10 bar)
// =====================
class SV7151PressureSensor : public SensorBase
{
public:
    SV7151PressureSensor(const std::string &varName,
                         double rawMax   = 32767.0,
                         double maMin    = 4.0,
                         double maMax    = 20.0,
                         double pMin     = 0.0,
                         double pMax     = 10.0)
        : SensorBase(RevPiAnalogInput(varName, rawMax)),
          m_maMin(maMin),
          m_maMax(maMax),
          m_pMin(pMin),
          m_pMax(pMax)
    {}

    bool readValue(double &pressure) override
    {
        long raw = 0;
        if (!m_channel.readRaw(raw)) {
            return false;
        }

        double mA = m_maMin + (double(raw) / m_channel.rawMax()) * (m_maMax - m_maMin);

        if (mA <= m_maMin)
            pressure = m_pMin;
        else if (mA >= m_maMax)
            pressure = m_pMax;
        else {
            double ratio = (mA - m_maMin) / (m_maMax - m_maMin);
            pressure = m_pMin + ratio * (m_pMax - m_pMin);
        }

        return true;
    }

private:
    double m_maMin;
    double m_maMax;
    double m_pMin;
    double m_pMax;
};

// =====================
// PT1000: Temperature (raw -> °C tuyến tính, ví dụ -50..150°C)
// =====================
class PT1000TemperatureSensor : public SensorBase
{
public:
    PT1000TemperatureSensor(const std::string &varName,
                            double rawMax   = 32767.0,
                            double tMin     = -50.0,
                            double tMax     = 150.0)
        : SensorBase(RevPiAnalogInput(varName, rawMax)),
          m_tMin(tMin),
          m_tMax(tMax)
    {}

    bool readValue(double &temperature) override
    {
        long raw = 0;
        if (!m_channel.readRaw(raw)) {
            return false;
        }

        double ratio = double(raw) / m_channel.rawMax();
        if (ratio < 0.0) ratio = 0.0;
        if (ratio > 1.0) ratio = 1.0;

        temperature = m_tMin + ratio * (m_tMax - m_tMin);
        return true;
    }

private:
    double m_tMin;
    double m_tMax;
};

// ===================================================
//           PHẦN RS485 / MODBUS RTU CHO RK700
// ===================================================

class ModbusRtuPort
{
public:
    ModbusRtuPort(const std::string &device,
                  int baud,
                  char parity,
                  int stopBits,
                  uint8_t slaveAddr)
        : m_device(device),
          m_baud(baud),
          m_parity(parity),
          m_stopBits(stopBits),
          m_slave(slaveAddr),
          m_fd(-1)
    {}

    ~ModbusRtuPort()
    {
        if (m_fd >= 0) {
            ::close(m_fd);
        }
    }

    bool openPort()
    {
        m_fd = ::open(m_device.c_str(), O_RDWR | O_NOCTTY | O_NONBLOCK);
        if (m_fd < 0) {
            perror("open");
            return false;
        }

        if (!setupTermios()) {
            ::close(m_fd);
            m_fd = -1;
            return false;
        }
        return true;
    }

    bool isOpen() const { return m_fd >= 0; }

    // Đọc Holding Registers (func 0x03)
    bool readHoldingRegisters(uint16_t startReg,
                              uint16_t count,
                              std::vector<uint16_t> &regs)
    {
        if (m_fd < 0) return false;

        uint8_t req[8];
        req[0] = m_slave;
        req[1] = 0x03; // Read Holding Registers
        req[2] = (startReg >> 8) & 0xFF;
        req[3] = (startReg     ) & 0xFF;
        req[4] = (count    >> 8) & 0xFF;
        req[5] = (count        ) & 0xFF;

        uint16_t crc = crc16(req, 6);
        req[6] = crc & 0xFF;       // CRC low
        req[7] = (crc >> 8) & 0xFF; // CRC high

        // Gửi request
        ssize_t written = ::write(m_fd, req, sizeof(req));
        if (written != (ssize_t)sizeof(req)) {
            perror("write");
            return false;
        }

        // Đợi thiết bị trả lời
        // Đơn giản: ngủ 20ms rồi đọc
        std::this_thread::sleep_for(std::chrono::milliseconds(20));

        // Dự kiến response: addr(1) + func(1) + byteCount(1) + N*2 + CRC(2)
        size_t expectedBytes = 5 + count * 2;
        if (expectedBytes > 256) expectedBytes = 256;

        uint8_t buf[256];
        ssize_t rd = ::read(m_fd, buf, expectedBytes);
        if (rd < 5) {
            // Có thể thử đọc thêm vài lần nếu muốn robust hơn
            perror("read");
            return false;
        }

        // Kiểm tra CRC
        if (!checkCrc(buf, rd)) {
            std::cerr << "Modbus CRC error\n";
            return false;
        }

        if (buf[0] != m_slave) {
            std::cerr << "Modbus slave mismatch\n";
            return false;
        }

        if (buf[1] != 0x03) {
            std::cerr << "Modbus function error or exception\n";
            return false;
        }

        uint8_t byteCount = buf[2];
        if (byteCount != count * 2 || rd < (3 + byteCount + 2)) {
            std::cerr << "Modbus byteCount mismatch\n";
            return false;
        }

        regs.clear();
        for (uint16_t i = 0; i < count; ++i) {
            uint16_t hi = buf[3 + 2*i];
            uint16_t lo = buf[3 + 2*i + 1];
            regs.push_back((hi << 8) | lo);
        }

        return true;
    }

private:
    std::string m_device;
    int         m_baud;
    char        m_parity;
    int         m_stopBits;
    uint8_t     m_slave;
    int         m_fd;

    bool setupTermios()
    {
        struct termios tio{};
        if (tcgetattr(m_fd, &tio) != 0) {
            perror("tcgetattr");
            return false;
        }

        cfmakeraw(&tio);

        speed_t speedFlag = B9600;
        switch (m_baud) {
            case 2400:  speedFlag = B2400; break;
            case 4800:  speedFlag = B4800; break;
            case 9600:  speedFlag = B9600; break;
            case 19200: speedFlag = B19200; break;
            case 38400: speedFlag = B38400; break;
            case 115200: speedFlag = B115200; break;
            default:    speedFlag = B9600; break;
        }

        cfsetispeed(&tio, speedFlag);
        cfsetospeed(&tio, speedFlag);

        // 8 data bits
        tio.c_cflag &= ~CSIZE;
        tio.c_cflag |= CS8;

        // Parity
        if (m_parity == 'E') {       // Even
            tio.c_cflag |= PARENB;
            tio.c_cflag &= ~PARODD;
        } else if (m_parity == 'O') { // Odd
            tio.c_cflag |= PARENB;
            tio.c_cflag |= PARODD;
        } else {                      // None
            tio.c_cflag &= ~PARENB;
        }

        // Stop bits
        if (m_stopBits == 2) tio.c_cflag |= CSTOPB;
        else                 tio.c_cflag &= ~CSTOPB;

        tio.c_cflag |= CLOCAL | CREAD;

        // Không dùng flow control
        tio.c_iflag &= ~(IXON | IXOFF | IXANY);

        // Set timeout: VTIME=5 -> 0.5s, VMIN=0
        tio.c_cc[VTIME] = 5;
        tio.c_cc[VMIN]  = 0;

        if (tcsetattr(m_fd, TCSANOW, &tio) != 0) {
            perror("tcsetattr");
            return false;
        }

        tcflush(m_fd, TCIOFLUSH);
        return true;
    }

    static uint16_t crc16(const uint8_t *data, size_t len)
    {
        uint16_t crc = 0xFFFF;
        for (size_t i = 0; i < len; ++i) {
            crc ^= data[i];
            for (int j = 0; j < 8; ++j) {
                if (crc & 0x0001)
                    crc = (crc >> 1) ^ 0xA001;
                else
                    crc >>= 1;
            }
        }
        return crc;
    }

    static bool checkCrc(const uint8_t *data, size_t len)
    {
        if (len < 3) return false;
        uint16_t expected = crc16(data, len - 2);
        uint16_t got = data[len - 2] | (uint16_t(data[len - 1]) << 8);
        return expected == got;
    }
};

// =====================
// RK700 Tilt Sensor (RS485 / Modbus RTU)
// =====================
//
// Giả định:
//  - Slave address: 1
//  - Baud: 9600 8N1
//  - Function: 0x03
//  - startReg: 0x0000, count=2
//  - reg0 = X*10 (độ), reg1 = Y*10 (độ), signed 16-bit
//
class RK700TiltSensor
{
public:
    RK700TiltSensor(const std::string &dev,
                    int baud      = 9600,
                    uint8_t slave = 1,
                    uint16_t startReg = 0x0000,
                    double scaleDegPerLsb = 0.1)
        : m_port(dev, baud, 'N', 1, slave),
          m_startReg(startReg),
          m_scale(scaleDegPerLsb)
    {}

    bool init()
    {
        return m_port.openPort();
    }

    // Đọc góc X, Y (độ)
    bool readAngles(double &xDeg, double &yDeg)
    {
        std::vector<uint16_t> regs;
        if (!m_port.readHoldingRegisters(m_startReg, 2, regs)) {
            return false;
        }
        if (regs.size() < 2) return false;

        // Dữ liệu thường là signed 16-bit
        int16_t rawX = static_cast<int16_t>(regs[0]);
        int16_t rawY = static_cast<int16_t>(regs[1]);

        xDeg = rawX * m_scale;
        yDeg = rawY * m_scale;
        return true;
    }

private:
    ModbusRtuPort m_port;
    uint16_t      m_startReg;
    double        m_scale;
};

// =====================
// Demo main: SV6051 + PT1000 + SV7151 + RK700
// =====================

static bool g_running = true;

void signalHandler(int)
{
    g_running = false;
}

int main()
{
    std::signal(SIGINT,  signalHandler);
    std::signal(SIGTERM, signalHandler);

    // Các biến analog trong PiCtory (thay cho đúng tên của bạn)
    SV6051FlowSensor        sv6051("AI_1", 32767.0, 4.0, 20.0, 0.0, 500.0);
    PT1000TemperatureSensor pt1000("AI_2", 32767.0, -50.0, 150.0);
    SV7151PressureSensor    sv7151("AI_3", 32767.0, 4.0, 20.0, 0.0, 10.0);

    // Thiết bị RS485: chỉnh lại /dev/tty... cho đúng RevPi của bạn
    // Ví dụ: /dev/ttyAMA0 hoặc /dev/ttyS1 hoặc /dev/ttyUSB0
    RK700TiltSensor rk700("/dev/ttyS1", 9600, 1, 0x0000, 0.1);

    if (!rk700.init()) {
        std::cerr << "Khong mo duoc cong RS485 cho RK700\n";
        // vẫn đọc analog bình thường
    }

    std::cout << "Doc SV6051 (flow), PT1000 (temp), SV7151 (pressure) qua piTest\n";
    std::cout << "Va RK700 (tilt X/Y) qua RS485 Modbus RTU\n";
    std::cout << "Nhan Ctrl+C de dung.\n\n";

    while (g_running) {
        double flow = 0.0;
        double temp = 0.0;
        double pres = 0.0;
        double xDeg = 0.0;
        double yDeg = 0.0;

        bool okFlow = sv6051.readValue(flow);
        bool okTemp = pt1000.readValue(temp);
        bool okPres = sv7151.readValue(pres);

        bool okTilt = false;
        if (rk700.init()) { // nếu init trước đó fail thì bỏ qua
            okTilt = rk700.readAngles(xDeg, yDeg);
        }

        if (!okFlow) std::cerr << "[ERR] SV6051\n";
        if (!okTemp) std::cerr << "[ERR] PT1000\n";
        if (!okPres) std::cerr << "[ERR] SV7151\n";
        if (!okTilt) std::cerr << "[ERR] RK700\n";

        std::cout
            << "Flow=" << (okFlow ? flow : NAN) << " L/min"
            << " | Temp=" << (okTemp ? temp : NAN) << " C"
            << " | Pres=" << (okPres ? pres : NAN) << " bar"
            << " | RK700 X=" << (okTilt ? xDeg : NAN) << " deg"
            << " , Y=" << (okTilt ? yDeg : NAN) << " deg"
            << std::endl;

        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }

    std::cout << "Thoat.\n";
    return 0;
}
