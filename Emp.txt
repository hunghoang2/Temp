#pragma once
#include <zmq.hpp>
#include <thread>
#include <atomic>
#include <functional>
#include <string>

class ZmqServer {
public:
    using MessageCallback = std::function<void(const std::string&)>;

    ZmqServer(int port);
    ~ZmqServer();

    void start();
    void stop();

    void setMessageCallback(MessageCallback cb);

private:
    void run();

    int m_port;
    std::thread m_thread;
    std::atomic<bool> m_running{false};

    zmq::context_t m_context{1};
    zmq::socket_t m_socket{m_context, zmq::socket_type::rep};

    MessageCallback m_callback;
};
#include "ZmqServer.h"
#include <iostream>

ZmqServer::ZmqServer(int port)
    : m_port(port)
{}

ZmqServer::~ZmqServer() {
    stop();
}

void ZmqServer::start() {
    if (m_running) return;
    m_running = true;

    m_thread = std::thread(&ZmqServer::run, this);
}

void ZmqServer::stop() {
    if (!m_running) return;
    m_running = false;

    // Gửi tín hiệu wake up socket
    m_socket.close();

    if (m_thread.joinable())
        m_thread.join();
}

void ZmqServer::setMessageCallback(MessageCallback cb) {
    m_callback = std::move(cb);
}

void ZmqServer::run() {
    try {
        std::string bind_addr = "tcp://*:" + std::to_string(m_port);
        m_socket.bind(bind_addr);
        std::cout << "[ZmqServer] Listening on " << bind_addr << std::endl;

        while (m_running) {
            zmq::message_t request;
            auto result = m_socket.recv(request, zmq::recv_flags::none);
            if (!result || !m_running)
                break;

            std::string msg(static_cast<char*>(request.data()), request.size());
            if (m_callback)
                m_callback(msg);

            // Gửi ACK lại
            m_socket.send(zmq::buffer("ACK"), zmq::send_flags::none);
        }
    } catch (std::exception& e) {
        std::cerr << "[ZmqServer] Error: " << e.what() << std::endl;
    }
}


