#pragma once
#include <opencv2/opencv.hpp>

enum TrackState
{
    TRACK_OK = 0,
    TRACK_SUSPICIOUS,
    TRACK_LOST
};

class TrackingValidator
{
public:
    TrackingValidator();

    void enableThermalCheck(bool enable);
    void enableEdgeCheck(bool enable);

    TrackState validate(const cv::Mat& thermalFrame, const cv::Rect& bbox);

private:
    // ===== Thermal signature =====
    bool thermalEnabled;
    float thermalContrastThresh;

    // ===== Edge density =====
    bool edgeEnabled;
    float edgeDensityThresh;

    // utils
    float computeThermalContrast(const cv::Mat& frame, const cv::Rect& roi);
    float computeEdgeDensity(const cv::Mat& roi);
};





#include "TrackingValidator.h"

TrackingValidator::TrackingValidator()
{
    thermalEnabled = true;
    edgeEnabled = true;

    thermalContrastThresh = 12.0f;   // độ chênh nhiệt tối thiểu
    edgeDensityThresh = 0.015f;      // mật độ cạnh tối thiểu
}

void TrackingValidator::enableThermalCheck(bool enable)
{
    thermalEnabled = enable;
}

void TrackingValidator::enableEdgeCheck(bool enable)
{
    edgeEnabled = enable;
}

TrackState TrackingValidator::validate(const cv::Mat& frame, const cv::Rect& bbox)
{
    if (bbox.width <= 0 || bbox.height <= 0)
        return TRACK_LOST;

    cv::Rect safeBox = bbox & cv::Rect(0, 0, frame.cols, frame.rows);
    cv::Mat roi = frame(safeBox);

    int score = 0;
    int maxScore = 0;

    // ===== Thermal check =====
    if (thermalEnabled)
    {
        maxScore++;
        float contrast = computeThermalContrast(frame, safeBox);
        if (contrast > thermalContrastThresh)
            score++;
    }

    // ===== Edge check =====
    if (edgeEnabled)
    {
        maxScore++;
        float edgeDensity = computeEdgeDensity(roi);
        if (edgeDensity > edgeDensityThresh)
            score++;
    }

    // ===== Decision =====
    if (score == maxScore)
        return TRACK_OK;
    else if (score > 0)
        return TRACK_SUSPICIOUS;
    else
        return TRACK_LOST;
}

float TrackingValidator::computeThermalContrast(const cv::Mat& frame, const cv::Rect& roi)
{
    cv::Scalar meanROI = cv::mean(frame(roi));

    // tạo vùng nền xung quanh ROI
    int margin = 20;
    cv::Rect bg(
        std::max(0, roi.x - margin),
        std::max(0, roi.y - margin),
        std::min(frame.cols - roi.x + margin, roi.width + 2 * margin),
        std::min(frame.rows - roi.y + margin, roi.height + 2 * margin)
    );

    cv::Mat bgRegion = frame(bg).clone();

    // xoá phần ROI khỏi background
    cv::rectangle(bgRegion,
                  cv::Rect(margin, margin, roi.width, roi.height),
                  0, -1);

    cv::Scalar meanBG = cv::mean(bgRegion);

    return static_cast<float>(meanROI[0] - meanBG[0]);
}

float TrackingValidator::computeEdgeDensity(const cv::Mat& roi)
{
    cv::Mat edges;
    cv::Canny(roi, edges, 50, 150);

    float edgePixels = static_cast<float>(cv::countNonZero(edges));
    float totalPixels = static_cast<float>(roi.total());

    return edgePixels / totalPixels;
}


