#include <modbus/modbus.h>
#include <string>
#include <vector>
#include <iostream>

bool write_string(modbus_t* ctx, int start_addr, const std::string& str, size_t max_chars)
{
    // copy và zero terminate
    std::string buf = str.substr(0, max_chars-1);
    buf.push_back('\0');

    // pad cho chẵn số byte
    if (buf.size() % 2 != 0) buf.push_back('\0');

    size_t reg_count = buf.size() / 2;
    std::vector<uint16_t> regs(reg_count);

    for (size_t i = 0; i < reg_count; i++) {
        unsigned char c1 = buf[2*i];
        unsigned char c2 = buf[2*i+1];
        // vendor thường định nghĩa: High=byte0, Low=byte1
        regs[i] = ((uint16_t)c1 << 8) | c2;
    }

    int rc = modbus_write_registers(ctx, start_addr, reg_count, regs.data());
    return (rc == (int)reg_count);
}

int main() {
    modbus_t* ctx = modbus_new_tcp("192.168.0.50", 502);
    modbus_set_slave(ctx, 1);
    if (modbus_connect(ctx) == -1) {
        std::cerr << "Connect failed\n";
        return 1;
    }

    if (write_string(ctx, 5121, "HELLO1234", 10)) {
        std::cout << "Write OK\n";
    } else {
        std::cerr << "Write failed\n";
    }

    modbus_close(ctx);
    modbus_free(ctx);
}
