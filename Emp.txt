typedef struct {
    /* ===== CONFIG (set once or tune runtime) ===== */
    double dt;                 // frame time (s), e.g. 0.04

    // deadband & mode
    double e_db;               // deadband in deg (e.g. 0.10)
    double w_static_th;        // deg/s threshold to detect moving target

    // alpha-beta filter
    double alpha;              // e.g. 0.75
    double beta;               // e.g. 0.10

    // lead (prediction)
    double Tlead_move;         // e.g. 0.14 s

    // setpoint rate limit
    double w_sp_max_static;    // deg/s (e.g. 10)
    double w_sp_max_move;      // deg/s (e.g. 35)

    /* ===== STATE ===== */
    int    inited;

    // encoder unwrap
    double enc_prev_wrapped;   // last encoder raw [0..360)
    double enc_cont;           // continuous encoder angle

    // target angle estimate (continuous)
    double theta_est;          // deg
    double omega_est;          // deg/s

    // output setpoint (continuous)
    double theta_set;          // deg
} PanTracker;


void pan_tracker_init(PanTracker* t, double enc_wrapped_deg)
{
    t->inited = 1;

    t->enc_prev_wrapped = wrap360(enc_wrapped_deg);
    t->enc_cont         = t->enc_prev_wrapped;

    t->theta_est = t->enc_cont;
    t->omega_est = 0.0;

    t->theta_set = t->enc_cont;
}

double pan_tracker_step(
    PanTracker* t,
    double enc_wrapped_deg,
    double e_cam_deg
) {
    if (!t->inited) {
        pan_tracker_init(t, enc_wrapped_deg);
        return wrap360(t->theta_set);
    }

    /* ===== 0) UNWRAP ENCODER ===== */
    enc_wrapped_deg = wrap360(enc_wrapped_deg);
    double d_enc = ang_diff_deg(enc_wrapped_deg, t->enc_prev_wrapped);
    t->enc_cont += d_enc;
    t->enc_prev_wrapped = enc_wrapped_deg;

    /* ===== 1) DEADZONE (STATIC STABILITY) ===== */
    if (fabs(e_cam_deg) < t->e_db) {
        return wrap360(t->theta_set);
    }

    /* ===== 2) TARGET ANGLE MEASUREMENT (CONTINUOUS) ===== */
    double theta_meas = t->enc_cont + e_cam_deg;

    /* ===== 3) ALPHAâ€“BETA FILTER ===== */
    double theta_pred0 = t->theta_est + t->omega_est * t->dt;
    double r = theta_meas - theta_pred0;

    t->theta_est  = theta_pred0 + t->alpha * r;
    t->omega_est += (t->beta / t->dt) * r;

    /* ===== 4) ADAPTIVE MODE ===== */
    int moving = (fabs(t->omega_est) >= t->w_static_th);

    /* ===== 5) LEAD PREDICTION ===== */
    double theta_pred = t->theta_est +
                        (moving ? t->omega_est * t->Tlead_move : 0.0);

    /* ===== 6) RATE-LIMITED SETPOINT UPDATE ===== */
    double w_sp_max = moving ? t->w_sp_max_move : t->w_sp_max_static;
    double max_step = w_sp_max * t->dt;

    double step = theta_pred - t->theta_set;
    if (step >  max_step) step =  max_step;
    if (step < -max_step) step = -max_step;

    t->theta_set += step;

    /* ===== 7) OUTPUT (WRAPPED) ===== */
    return wrap360(t->theta_set);
}

