typedef struct {
    double theta_est, omega_est;
    double theta_set;
    double theta_set_prev;
    double theta_meas_prev;
    int    inited;
} Tracker;

double clampd(double x,double lo,double hi){ if(x<lo) return lo; if(x>hi) return hi; return x; }

void tracker_init(Tracker* t, double theta0){
    t->theta_est = theta0;
    t->omega_est = 0.0;
    t->theta_set = theta0;
    t->theta_set_prev = theta0;
    t->theta_meas_prev = theta0;
    t->inited = 1;
}

double tracker_step(
    Tracker* t,
    double dt,
    double theta_enc,     // deg
    double e_cam,         // deg
    // params
    double e_db,
    double alpha, double beta,
    double w_static_th,
    double Tlead_move,
    double w_sp_max_static,
    double w_sp_max_move
){
    if (!t->inited) tracker_init(t, theta_enc);

    // deadband: hold to kill jitter
    if (fabs(e_cam) < e_db) {
        return t->theta_set_prev;
    }

    // measurement: absolute target angle
    double theta_meas = theta_enc + e_cam;

    // alpha-beta on theta_target
    double theta_pred0 = t->theta_est + t->omega_est * dt;
    double r = theta_meas - theta_pred0;
    t->theta_est = theta_pred0 + alpha * r;
    t->omega_est = t->omega_est + (beta/dt) * r;

    // adaptive mode
    int moving = (fabs(t->omega_est) >= w_static_th);

    // lead prediction (only when moving)
    double theta_pred = t->theta_est + (moving ? t->omega_est * Tlead_move : 0.0);

    // rate-limited absolute setpoint
    double w_sp_max = moving ? w_sp_max_move : w_sp_max_static;
    double max_step = w_sp_max * dt;

    double step = clampd(theta_pred - t->theta_set_prev, -max_step, +max_step);
    t->theta_set = t->theta_set_prev + step;

    t->theta_set_prev = t->theta_set;
    return t->theta_set;
}
