// PanTiltTracker.h
#pragma once

#include <QObject>
#include <QThread>
#include <QMutex>
#include <atomic>
#include <cmath>
#include <Eigen/Dense>

class PanTiltTracker : public QThread {
    Q_OBJECT

public:
    explicit PanTiltTracker(double kpPan, double kpTilt, QObject *parent = nullptr)
      : QThread(parent)
      , KpPan_(kpPan)
      , KpTilt_(kpTilt)
      , runFlag_(false)
      , lat0_(0), lon0_(0), alt0_(0)
    {}

    ~PanTiltTracker() override {
        stopTracking();
    }

    // Thiết lập toạ độ LLA của camera làm gốc ENU
    void setCameraLLA(double lat, double lon, double alt) {
        QMutexLocker locker(&mutex_);
        lat0_ = lat * M_PI/180.0;
        lon0_ = lon * M_PI/180.0;
        alt0_ = alt;
        llaToECEF(lat0_, lon0_, alt0_, ecefCam_);
    }

public slots:
    // Nhận toạ độ mục tiêu theo LLA (deg,deg,m), chuyển về ENU rồi update Kalman
    void setRadarMeasurement(double lat, double lon, double alt) {
        double latR = lat * M_PI/180.0;
        double lonR = lon * M_PI/180.0;
        Eigen::Vector3d ecefR;
        llaToECEF(latR, lonR, alt, ecefR);

        Eigen::Vector3d enu;
        ecefToENU(ecefR, ecefCam_, lat0_, lon0_, enu);

        QMutexLocker locker(&mutex_);
        kalman_.update(enu);
    }

    // Bắt đầu vòng điều khiển 30 Hz
    void startTracking() {
        if (!runFlag_) {
            runFlag_ = true;
            QThread::start();
        }
    }

    // Dừng vòng điều khiển
    void stopTracking() {
        if (runFlag_) {
            runFlag_ = false;
            wait();
        }
    }

signals:
    // Phát lệnh pan/tilt (đơn vị rad)
    void panTiltCommand(double pan, double tilt);

protected:
    void run() override {
        const double dt = 1.0 / 30.0;
        while (runFlag_) {
            {
                QMutexLocker locker(&mutex_);
                kalman_.predict(dt);
                auto st = kalman_.getState().x;
                // st = [E, N, U, vE, vN, vU]
                double pan  = std::atan2(st(0), st(2));  // East vs Up
                double tilt = std::atan2(st(1), st(2));  // North vs Up
                emit panTiltCommand(KpPan_ * pan,
                                    KpTilt_ * tilt);
            }
            QThread::msleep(static_cast<unsigned long>(dt * 1000));
        }
    }

private:
    // WGS84 ellipsoid constants
    static constexpr double a_  = 6378137.0;
    static constexpr double f_  = 1.0/298.257223563;
    static constexpr double e2_ = f_*(2 - f_);

    // Chuyển LLA -> ECEF
    void llaToECEF(double lat, double lon, double h, Eigen::Vector3d &ecef) const {
        double N = a_ / std::sqrt(1 - e2_ * std::sin(lat)*std::sin(lat));
        ecef.x() = (N + h) * std::cos(lat) * std::cos(lon);
        ecef.y() = (N + h) * std::cos(lat) * std::sin(lon);
        ecef.z() = (N*(1 - e2_) + h) * std::sin(lat);
    }

    // Chuyển ECEF -> ENU tại reference (lat0_, lon0_)
    void ecefToENU(const Eigen::Vector3d &ecef,
                   const Eigen::Vector3d &ecefRef,
                   double lat0, double lon0,
                   Eigen::Vector3d &enu) const
    {
        Eigen::Vector3d d = ecef - ecefRef;
        double sinLat = std::sin(lat0), cosLat = std::cos(lat0);
        double sinLon = std::sin(lon0), cosLon = std::cos(lon0);
        Eigen::Matrix3d R;
        R << -sinLon,           cosLon,          0,
             -sinLat*cosLon, -sinLat*sinLon,  cosLat,
              cosLat*cosLon,  cosLat*sinLon,  sinLat;
        enu = R * d;
    }

    // Bộ lọc Kalman nội bộ (theo ENU)
    struct KalmanTracker {
        Eigen::VectorXd x;   // [E N U vE vN vU]
        Eigen::MatrixXd P, Q, R, H;

        KalmanTracker() {
            x = Eigen::VectorXd::Zero(6);
            P = Eigen::MatrixXd::Identity(6,6) * 1e3;
            Q = Eigen::MatrixXd::Identity(6,6) * 0.01;
            R = Eigen::Matrix3d::Identity() * 0.1;
            H = Eigen::MatrixXd::Zero(3,6);
            H.block<3,3>(0,0) = Eigen::Matrix3d::Identity();
        }

        void predict(double dt) {
            Eigen::MatrixXd F = Eigen::MatrixXd::Identity(6,6);
            F.block<3,3>(0,3) = Eigen::Matrix3d::Identity() * dt;
            x = F * x;
            P = F * P * F.transpose() + Q;
        }

        void update(const Eigen::Vector3d &z) {
            Eigen::Vector3d y = z - H * x;
            Eigen::MatrixXd S = H * P * H.transpose() + R;
            Eigen::MatrixXd K = P * H.transpose() * S.inverse();
            x += K * y;
            P = (Eigen::MatrixXd::Identity(6,6) - K * H) * P;
        }

        struct State { Eigen::VectorXd x; Eigen::MatrixXd P; };
        State getState() const { return { x, P }; }
    } kalman_;

    QMutex             mutex_;
    std::atomic<bool>  runFlag_;
    double             KpPan_, KpTilt_;

    // Reference cho chuyển ECEF -> ENU
    double             lat0_, lon0_, alt0_;
    Eigen::Vector3d    ecefCam_;
};
